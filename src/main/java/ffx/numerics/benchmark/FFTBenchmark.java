
package ffx.numerics.benchmark;

import edu.rit.pj.ParallelTeam;
import ffx.numerics.fft.Complex;
import ffx.numerics.fft.Complex2D;
import ffx.numerics.fft.Complex3D;
import ffx.numerics.fft.Complex3DParallel;
import ffx.numerics.fft.DataLayout1D;
import ffx.numerics.fft.DataLayout2D;
import ffx.numerics.fft.DataLayout3D;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;

import java.util.Arrays;
import java.util.Random;

import static java.lang.Math.min;
import static java.util.concurrent.TimeUnit.MICROSECONDS;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static org.openjdk.jmh.annotations.Mode.AverageTime;

/**
 * Information on the benchmarking process:
 * <p>
 * This <a href="https://blogs.oracle.com/javamagazine/post/java-hotspot-hsdis-disassembler">blog</a> discusses the
 * Java Hotspot disassembler (hsdis), which is a shared library that allows you to see the assembly code generated by the JIT compiler.
 * <p>
 * Pre-built hsdis <a href="https://chriswhocodes.com/hsdis/"> binaries</a> are available for download.
 * <p>
 * More information on hsdis is available:
 * https://github.com/openjdk/jdk/blob/master/src/utils/hsdis/README
 * https://github.com/AdoptOpenJDK/jitwatch/wiki/Building-hsdis
 * <p>
 * Arm64 assembly code <a href="https://developer.arm.com/documentation/dui0801/l/A64-SIMD-Vector-Instructions">manual</a>.
 * <p>
 * Tips from Paul Sandoz (a JVM SIMD author) are
 * <a href="https://github.com/PaulSandoz/vector-api-dev-live-10-2021/blob/main/src/main/java/jmh/BytesHashcode.java">available</a>.
 * <p>
 * Once the hsdis library is installed, you can run the following command to see the assembly code generated by the JIT compiler:
 * java -XX:-TieredCompilation -XX:LoopUnrollLimit=0 -jar target/benchmarks.jar -prof dtraceasm FFTBenchmark.Complex128Blocked
 * <p>
 * The flags being used by the JVM can be seen by running the following command:
 * java -XX:+PrintFlagsFinal -version
 */
public class FFTBenchmark {

  /**
   * Perform 2 test warm-up iterations
   */
  private final static int warmUpIterations = 2;
  /**
   * Each warm-up iteration will run for this many seconds.
   */
  private final static int warmupTime = 1;
  /**
   * Perform 3 test measurement iterations
   */
  private final static int measurementIterations = 5;
  /**
   * Each measurement iteration will run for this many seconds.
   */
  private final static int measurementTime = 1;

  public static int nThreads = min(ParallelTeam.getDefaultThreadCount(), 8);
  public static ParallelTeam parallelTeam = new ParallelTeam(nThreads);
  public static final double[] inDouble32 = new double[32 * 2];
  public static final double[] inDouble64 = new double[64 * 2];
  public static final double[] inDouble128 = new double[128 * 2];
  public static final double[] inDouble256 = new double[256 * 2];

  public static final double[] inDouble2D32Interleaved = new double[32 * 32 * 2];
  public static final double[] inDouble2D32Blocked = new double[32 * 32 * 2];
  public static final double[] inDouble2D64Interleaved = new double[64 * 64 * 2];
  public static final double[] inDouble2D64Blocked = new double[64 * 64 * 2];

  public static final double[] inDouble3D32Conv = new double[32 * 32 * 32];
  public static final double[] inDouble3D64Conv = new double[64 * 64 * 64];
  public static final double[] inDouble3D32Interleaved = new double[32 * 32 * 32 * 2];
  public static final double[] inDouble3D32Blocked = new double[32 * 32 * 32 * 2];
  public static final double[] inDouble3D64Interleaved = new double[64 * 64 * 64 * 2];
  public static final double[] inDouble3D64Blocked = new double[64 * 64 * 64 * 2];

  // Initialize the input arrays with random values.
  static {
    Random random = new Random(1);
    for (int i = 0; i < 32; i++) {
      inDouble32[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 64; i++) {
      inDouble64[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 128; i++) {
      inDouble128[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 256; i++) {
      inDouble256[i * 2] = random.nextDouble();
    }

    int index = 0;
    int index3D = 0;
    for (int x = 0; x < 32; x++) {
      for (int y = 0; y < 32; y++) {

        inDouble2D32Blocked[index] = random.nextDouble();
        inDouble2D32Interleaved[2 * index] = random.nextDouble();
        index++;
        for (int z = 0; z < 32; z++) {
          inDouble3D32Conv[index3D] = random.nextDouble();
          inDouble3D32Blocked[index3D] = random.nextDouble();
          inDouble3D32Interleaved[2 * index3D] = random.nextDouble();
          index3D++;
        }
      }
    }

    index = 0;
    index3D = 0;
    for (int x = 0; x < 64; x++) {
      for (int y = 0; y < 64; y++) {
        inDouble2D64Blocked[index] = random.nextDouble();
        inDouble2D64Interleaved[2 * index] = random.nextDouble();
        index++;
        for (int z = 0; z < 64; z++) {
          inDouble3D64Conv[index3D] = random.nextDouble();
          inDouble3D64Blocked[index3D] = random.nextDouble();
          inDouble3D64Interleaved[2 * index3D] = random.nextDouble();
          index3D++;
        }
      }
    }

  }

  @State(Scope.Thread)
  public static class Complex32 {
    Complex complex = new Complex(32);
    double[] in = Arrays.copyOf(inDouble32, inDouble32.length);
  }

  @State(Scope.Thread)
  public static class Complex32Blocked {
    Complex complex = new Complex(32, DataLayout1D.BLOCKED, 32);
    double[] in = Arrays.copyOf(inDouble32, inDouble32.length);
  }

  @State(Scope.Thread)
  public static class Complex64 {
    Complex complex = new Complex(64);
    double[] in = Arrays.copyOf(inDouble64, inDouble64.length);
  }

  @State(Scope.Thread)
  public static class Complex64Blocked {
    Complex complex = new Complex(64, DataLayout1D.BLOCKED, 64);
    double[] in = Arrays.copyOf(inDouble64, inDouble64.length);
  }

  @State(Scope.Thread)
  public static class Complex128 {
    Complex complex = new Complex(128);
    double[] in = Arrays.copyOf(inDouble128, inDouble128.length);
  }

  @State(Scope.Thread)
  public static class Complex128Blocked {
    Complex complex = new Complex(128, DataLayout1D.BLOCKED, 128);
    double[] in = Arrays.copyOf(inDouble128, inDouble128.length);
  }

  @State(Scope.Thread)
  public static class Complex256 {
    Complex complex = new Complex(256);
    double[] in = Arrays.copyOf(inDouble256, inDouble256.length);
  }

  @State(Scope.Thread)
  public static class Complex256Blocked {
    Complex complex = new Complex(256, DataLayout1D.BLOCKED, 256);
    double[] in = Arrays.copyOf(inDouble256, inDouble256.length);
  }

  @State(Scope.Thread)
  public static class Complex32Blocked2DFFT {
    Complex2D complex2D = new Complex2D(32, 32, DataLayout2D.BLOCKED_XY, 32 * 32);
    double[] in = Arrays.copyOf(inDouble2D32Blocked, inDouble2D32Blocked.length);
  }

  @State(Scope.Thread)
  public static class Complex32Interleaved2DFFT {
    Complex2D complex2D = new Complex2D(32, 32, DataLayout2D.INTERLEAVED, 1);
    double[] in = Arrays.copyOf(inDouble2D32Interleaved, inDouble2D32Interleaved.length);
  }

  @State(Scope.Thread)
  public static class Complex32Blocked3DFFT {
    Complex3D complex3D = new Complex3D(32, 32, 32, DataLayout3D.BLOCKED_XY);
    double[] in = Arrays.copyOf(inDouble3D32Blocked, inDouble3D32Blocked.length);

    {
      complex3D.setRecip(inDouble3D32Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex32Interleaved3DFFT {
    Complex3D complex3D = new Complex3D(32, 32, 32, DataLayout3D.INTERLEAVED);
    double[] in = Arrays.copyOf(inDouble3D32Interleaved, inDouble3D32Interleaved.length);

    {
      complex3D.setRecip(inDouble3D32Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex64Blocked2DFFT {
    Complex2D complex2D = new Complex2D(64, 64, DataLayout2D.BLOCKED_XY, 64 * 64);
    double[] in = Arrays.copyOf(inDouble2D64Blocked, inDouble2D64Blocked.length);
  }

  @State(Scope.Thread)
  public static class Complex64Interleaved2DFFT {
    Complex2D complex2D = new Complex2D(64, 64, DataLayout2D.INTERLEAVED, 1);
    double[] in = Arrays.copyOf(inDouble2D64Interleaved, inDouble2D64Interleaved.length);
  }

  @State(Scope.Thread)
  public static class Complex64Blocked3DFFT {
    Complex3D complex3D = new Complex3D(64, 64, 64, DataLayout3D.BLOCKED_XY);
    double[] in = Arrays.copyOf(inDouble3D64Blocked, inDouble3D64Blocked.length);

    {
      complex3D.setRecip(inDouble3D64Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex64Interleaved3DFFT {
    Complex3D complex3D = new Complex3D(64, 64, 64, DataLayout3D.INTERLEAVED);
    double[] in = Arrays.copyOf(inDouble3D64Interleaved, inDouble3D64Interleaved.length);

    {
      complex3D.setRecip(inDouble3D64Conv);
    }
  }


  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032(Complex32 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked(Complex32Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032SIMD(Complex32 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032SIMDBlocked(Complex32Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }
  
  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064(Complex64 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked(Complex64Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064SIMD(Complex64 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064SIMDBlocked(Complex64Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1,
      jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128Blocked(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMD(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlocked(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }
  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256(Complex256 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256Blocked(Complex256Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256SIMD(Complex256 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256SIMDBlocked(Complex256Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked2DFFTScalar(Complex32Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked2DFFTSIMD(Complex32Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked2DFFTSIMDPacked(Complex32Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Interleaved2DFFTScalar(Complex32Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Interleaved2DFFTSIMD(Complex32Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Interleaved2DFFTSIMDPacked(Complex32Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked3DConvScalar(Complex32Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked3DConvSIMD(Complex32Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked3DConvSIMDPacked(Complex32Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.fft(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Interleaved3DConvScalar(Complex32Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Interleaved3DConvSIMD(Complex32Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Interleaved3DConvSIMDPacked(Complex32Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked2DFFTScalar(Complex64Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked2DFFTSIMD(Complex64Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked2DFFTSIMDPacked(Complex64Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Interleaved2DFFTScalar(Complex64Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Interleaved2DFFTSIMD(Complex64Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Interleaved2DFFTSIMDPacked(Complex64Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked3DConvScalar(Complex64Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked3DConvSIMD(Complex64Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked3DConvSIMDPacked(Complex64Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Interleaved3DConvScalar(Complex64Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Interleaved3DConvSIMD(Complex64Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Interleaved3DConvSIMDPacked(Complex64Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

}


