
package ffx.numerics.benchmark;

import edu.rit.pj.ParallelTeam;
import ffx.numerics.fft.Complex;
import ffx.numerics.fft.Complex3DParallel;
import ffx.numerics.fft.DataLayout1D;
import jdk.incubator.vector.DoubleVector;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;

import java.util.Arrays;
import java.util.Random;

import static java.util.concurrent.TimeUnit.MICROSECONDS;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static org.openjdk.jmh.annotations.Mode.AverageTime;

/**
 * Information on the benchmarking process:
 * <p>
 * This <a href="https://blogs.oracle.com/javamagazine/post/java-hotspot-hsdis-disassembler">blog</a> discusses the
 * Java Hotspot disassembler (hsdis), which is a shared library that allows you to see the assembly code generated by the JIT compiler.
 * <p>
 * Pre-built hsdis <a href="https://chriswhocodes.com/hsdis/"> binaries</a> are available for download.
 * <p>
 * More information on hsdis is available:
 * https://github.com/openjdk/jdk/blob/master/src/utils/hsdis/README
 * https://github.com/AdoptOpenJDK/jitwatch/wiki/Building-hsdis
 * <p>
 * Arm64 assembly code <a href="https://developer.arm.com/documentation/dui0801/l/A64-SIMD-Vector-Instructions">manual</a>.
 * <p>
 * Tips from Paul Sandoz (a JVM SIMD author) are
 * <a href="https://github.com/PaulSandoz/vector-api-dev-live-10-2021/blob/main/src/main/java/jmh/BytesHashcode.java">available</a>.
 * <p>
 * Once the hsdis library is installed, you can run the following command to see the assembly code generated by the JIT compiler:
 * java -XX:-TieredCompilation -XX:LoopUnrollLimit=0 -jar target/benchmarks.jar -prof dtraceasm FFTBenchmark.Complex128Blocked
 * <p>
 * The flags being used by the JVM can be seen by running the following command:
 * java -XX:+PrintFlagsFinal -version
 */
public class FFTBenchmark {

  private static final int SPECIES_LENGTH = DoubleVector.SPECIES_PREFERRED.length();

  /**
   * Perform 2 test warm-up iterations
   */
  private final static int warmUpIterations = 2;
  /**
   * Each warm-up iteration will run for this many seconds.
   */
  private final static int warmupTime = 1;
  /**
   * Perform 3 test measurement iterations
   */
  private final static int measurementIterations = 5;
  /**
   * Each measurement iteration will run for this many seconds.
   */
  private final static int measurementTime = 1;

  public static final double[] inDouble32 = new double[32 * 2];
  public static final double[] inDouble64 = new double[64 * 2];
  public static final double[] inDouble128 = new double[128 * 2];
  public static final double[] inDouble256 = new double[256 * 2];

  public static final double[] inDouble256_SPECIES_BLOCKED = new double[256 * 2 * SPECIES_LENGTH];
  public static final double[] inDouble256_SPECIES_INTERLEAVED = new double[256 * 2 * SPECIES_LENGTH];

  // Initialize the input arrays with random values.
  static {
    Random random = new Random(1);
    for (int i = 0; i < 32; i++) {
      inDouble32[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 64; i++) {
      inDouble64[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 128; i++) {
      inDouble128[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 256; i++) {
      inDouble256[i * 2] = random.nextDouble();
    }
    for (int f = 0; f < SPECIES_LENGTH; f++) {
      // Blocked
      for (int i = 0; i < 256; i++) {
        inDouble256_SPECIES_BLOCKED[i + f * SPECIES_LENGTH] = random.nextDouble();
      }
      // Interleaved
      for (int i = 0; i < 256; i++) {
        inDouble256_SPECIES_INTERLEAVED[i * 2 + f * SPECIES_LENGTH] = random.nextDouble();
      }
    }
  }

  @State(Scope.Thread)
  public static class Complex32 {
    Complex complex = new Complex(32);
    double[] in = Arrays.copyOf(inDouble32, inDouble32.length);
  }

  @State(Scope.Thread)
  public static class Complex32Blocked {
    Complex complex = new Complex(32, DataLayout1D.BLOCKED, 32);
    double[] in = Arrays.copyOf(inDouble32, inDouble32.length);
  }

  @State(Scope.Thread)
  public static class Complex32_3D {
    public final ParallelTeam parallelTeam = new ParallelTeam();
    public final double[] in = Complex3DParallel.initRandomData(32, parallelTeam);
    Complex3DParallel complex3DParallel = new Complex3DParallel(32, 32, 32, parallelTeam);
  }

  @State(Scope.Thread)
  public static class Complex64 {
    Complex complex = new Complex(64);
    double[] in = Arrays.copyOf(inDouble64, inDouble64.length);
  }

  @State(Scope.Thread)
  public static class Complex64Blocked {
    Complex complex = new Complex(64, DataLayout1D.BLOCKED, 64);
    double[] in = Arrays.copyOf(inDouble64, inDouble64.length);
  }

  @State(Scope.Thread)
  public static class Complex128 {
    Complex complex = new Complex(128);
    double[] in = Arrays.copyOf(inDouble128, inDouble128.length);
  }

  @State(Scope.Thread)
  public static class Complex128Blocked {
    Complex complex = new Complex(128, DataLayout1D.BLOCKED, 128);
    double[] in = Arrays.copyOf(inDouble128, inDouble128.length);
  }

  @State(Scope.Thread)
  public static class Complex256 {
    Complex complex = new Complex(256);
    double[] in = Arrays.copyOf(inDouble256, inDouble256.length);
  }

  @State(Scope.Thread)
  public static class Complex256Blocked {
    Complex complex = new Complex(256, DataLayout1D.BLOCKED, 256);
    double[] in = Arrays.copyOf(inDouble256, inDouble256.length);
  }

  @State(Scope.Thread)
  public static class Complex256InterleavedNFFT {
    Complex complex = new Complex(256, DataLayout1D.INTERLEAVED, 256, SPECIES_LENGTH);
    double[] in = Arrays.copyOf(inDouble256_SPECIES_INTERLEAVED, inDouble256_SPECIES_INTERLEAVED.length);
  }

  @State(Scope.Thread)
  public static class Complex256BlockedNFFT {
    Complex complex = new Complex(256, DataLayout1D.BLOCKED, 256, SPECIES_LENGTH);
    double[] in = Arrays.copyOf(inDouble256_SPECIES_BLOCKED, inDouble256_SPECIES_BLOCKED.length);
    static {
      System.out.println("SPECIES_LENGTH = " + SPECIES_LENGTH);
    }
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032(Complex32 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032Blocked(Complex32Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032SIMD(Complex32 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032SIMDBlocked(Complex32Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex032_3D(Complex32_3D state, Blackhole blackhole) {
    state.complex3DParallel.fft(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064(Complex64 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064Blocked(Complex64Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064SIMD(Complex64 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex064SIMDBlocked(Complex64Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1,
      jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128Blocked(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMD(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDLoop004(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(4);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDLoop008(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(8);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDLoop016(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(16);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDLoop032(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(32);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDLoop064(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(64);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDLoop128(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(128);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlocked(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlockedLoop004(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(4);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlockedLoop008(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(8);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlockedLoop016(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(16);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlockedLoop032(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(32);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlockedLoop064(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(64);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex128SIMDBlockedLoop128(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.setMinSIMDLoopLength(128);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256(Complex256 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256Blocked(Complex256Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256SIMD(Complex256 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256SIMDBlocked(Complex256Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256InterleavedNFFT(Complex256InterleavedNFFT state, Blackhole blackhole) {
    int nextFFT = 256 * 2;
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2, nextFFT);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256BlockedNFFT(Complex256BlockedNFFT state, Blackhole blackhole) {
    int nextFFT = 256 * 2;
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1, nextFFT);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256SIMDInterleavedNFFT(Complex256InterleavedNFFT state, Blackhole blackhole) {
    int nextFFT = 256 * 2;
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2, nextFFT);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void Complex256SIMDBlockedNFFT(Complex256BlockedNFFT state, Blackhole blackhole) {
    int nextFFT = 256 * 2;
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1, nextFFT);
    blackhole.consume(state.in);
  }
}
