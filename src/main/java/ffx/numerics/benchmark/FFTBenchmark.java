
package ffx.numerics.benchmark;

import edu.rit.pj.ParallelTeam;
import ffx.numerics.fft.Complex;
import ffx.numerics.fft.Complex1D;
import ffx.numerics.fft.Complex2D;
import ffx.numerics.fft.Complex3D;
import ffx.numerics.fft.Complex3DParallel;
import ffx.numerics.fft.DataLayout1D;
import ffx.numerics.fft.DataLayout2D;
import ffx.numerics.fft.DataLayout3D;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;

import java.util.Arrays;
import java.util.Random;

import static java.lang.Math.min;
import static java.util.concurrent.TimeUnit.MICROSECONDS;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static org.openjdk.jmh.annotations.Mode.AverageTime;

/**
 * Information on the benchmarking process:
 * <p>
 * This <a href="https://blogs.oracle.com/javamagazine/post/java-hotspot-hsdis-disassembler">blog</a> discusses the
 * Java Hotspot disassembler (hsdis), which is a shared library that allows you to see the assembly code generated by the JIT compiler.
 * <p>
 * Pre-built hsdis <a href="https://chriswhocodes.com/hsdis/"> binaries</a> are available for download.
 * <p>
 * More information on hsdis is available:
 * https://github.com/openjdk/jdk/blob/master/src/utils/hsdis/README
 * https://github.com/AdoptOpenJDK/jitwatch/wiki/Building-hsdis
 * <p>
 * Arm64 assembly code <a href="https://developer.arm.com/documentation/dui0801/l/A64-SIMD-Vector-Instructions">manual</a>.
 * <p>
 * Tips from Paul Sandoz (a JVM SIMD author) are
 * <a href="https://github.com/PaulSandoz/vector-api-dev-live-10-2021/blob/main/src/main/java/jmh/BytesHashcode.java">available</a>.
 * <p>
 * Once the hsdis library is installed, you can run the following command to see the assembly code generated by the JIT compiler:
 * java -XX:-TieredCompilation -XX:LoopUnrollLimit=0 -jar target/benchmarks.jar -prof dtraceasm FFTBenchmark.Complex128Blocked
 * <p>
 * The flags being used by the JVM can be seen by running the following command:
 * java -XX:+PrintFlagsFinal -version
 */
public class FFTBenchmark {

  /**
   * Perform 2 test warm-up iterations
   */
  private final static int warmUpIterations = 5;
  /**
   * Each warm-up iteration will run for this many seconds.
   */
  private final static int warmupTime = 2;
  /**
   * Perform 3 test measurement iterations
   */
  private final static int measurementIterations = 10;
  /**
   * Each measurement iteration will run for this many seconds.
   */
  private final static int measurementTime = 2;

  public static int requestedThreads = Integer.parseInt(System.getProperty("pj.nt", "8"));
  public static int nThreads = min(ParallelTeam.getDefaultThreadCount(), requestedThreads);
  public static ParallelTeam parallelTeam = new ParallelTeam(nThreads);
  public static final double[] inDouble64 = new double[64 * 2];
  public static final double[] inDouble128 = new double[128 * 2];
  public static final double[] inDouble256 = new double[256 * 2];
  public static final double[] inDouble512 = new double[512 * 2];
  public static final double[] inDouble1024 = new double[1024 * 2];

  public static final double[] inDouble2D64Interleaved = new double[64 * 64 * 2];
  public static final double[] inDouble2D64Blocked = new double[64 * 64 * 2];
  public static final double[] inDouble2D128Interleaved = new double[128 * 128 * 2];
  public static final double[] inDouble2D128Blocked = new double[128 * 128 * 2];

  public static final double[] inDouble3D64Conv = new double[64 * 64 * 64];
  public static final double[] inDouble3D64Interleaved = new double[64 * 64 * 64 * 2];
  public static final double[] inDouble3D64Blocked = new double[64 * 64 * 64 * 2];

  public static final double[] inDouble3D128Conv = new double[128 * 128 * 128];
  public static final double[] inDouble3D128Interleaved = new double[128 * 128 * 128 * 2];
  public static final double[] inDouble3D128Blocked = new double[128 * 128 * 128 * 2];

  // Initialize the input arrays with random values.
  static {
    Random random = new Random(1);
    for (int i = 0; i < 64; i++) {
      inDouble64[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 128; i++) {
      inDouble128[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 256; i++) {
      inDouble256[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 512; i++) {
      inDouble512[i * 2] = random.nextDouble();
    }
    for (int i = 0; i < 1024; i++) {
      inDouble1024[i * 2] = random.nextDouble();
    }

    int index = 0;
    int index3D = 0;
    for (int x = 0; x < 64; x++) {
      for (int y = 0; y < 64; y++) {
        inDouble2D64Blocked[index] = random.nextDouble();
        inDouble2D64Interleaved[2 * index] = random.nextDouble();
        index++;
        for (int z = 0; z < 64; z++) {
          inDouble3D64Conv[index3D] = random.nextDouble();
          inDouble3D64Blocked[index3D] = random.nextDouble();
          inDouble3D64Interleaved[2 * index3D] = random.nextDouble();
          index3D++;
        }
      }
    }

    index = 0;
    index3D = 0;
    for (int x = 0; x < 128; x++) {
      for (int y = 0; y < 128; y++) {
        inDouble2D128Blocked[index] = random.nextDouble();
        inDouble2D128Interleaved[2 * index] = random.nextDouble();
        index++;
        for (int z = 0; z < 128; z++) {
          inDouble3D128Conv[index3D] = random.nextDouble();
          inDouble3D128Blocked[index3D] = random.nextDouble();
          inDouble3D128Interleaved[2 * index3D] = random.nextDouble();
          index3D++;
        }
      }
    }
  }

  @State(Scope.Thread)
  public static class Complex64 {
    Complex complex = new Complex(64);
    double[] in = Arrays.copyOf(inDouble64, inDouble64.length);
  }

  @State(Scope.Thread)
  public static class Complex64Blocked {
    Complex complex = new Complex(64, DataLayout1D.BLOCKED, 64);
    double[] in = Arrays.copyOf(inDouble64, inDouble64.length);
  }

  @State(Scope.Thread)
  public static class Complex128 {
    Complex complex = new Complex(128);
    double[] in = Arrays.copyOf(inDouble128, inDouble128.length);
  }

  @State(Scope.Thread)
  public static class Complex128Blocked {
    Complex complex = new Complex(128, DataLayout1D.BLOCKED, 128);
    double[] in = Arrays.copyOf(inDouble128, inDouble128.length);
  }

  @State(Scope.Thread)
  public static class Complex256 {
    Complex complex = new Complex(256);
    double[] in = Arrays.copyOf(inDouble256, inDouble256.length);
  }

  @State(Scope.Thread)
  public static class Complex256Blocked {
    Complex complex = new Complex(256, DataLayout1D.BLOCKED, 256);
    double[] in = Arrays.copyOf(inDouble256, inDouble256.length);
  }

  @State(Scope.Thread)
  public static class Complex512 {
    Complex complex = new Complex(512);
    double[] in = Arrays.copyOf(inDouble512, inDouble512.length);
  }

  @State(Scope.Thread)
  public static class Complex512Blocked {
    Complex complex = new Complex(512, DataLayout1D.BLOCKED, 512);
    double[] in = Arrays.copyOf(inDouble512, inDouble512.length);
  }

  @State(Scope.Thread)
  public static class Complex1024 {
    Complex complex = new Complex(1024);
    double[] in = Arrays.copyOf(inDouble1024, inDouble1024.length);
  }

  @State(Scope.Thread)
  public static class Complex1024Blocked {
    Complex complex = new Complex(1024, DataLayout1D.BLOCKED, 1024);
    double[] in = Arrays.copyOf(inDouble1024, inDouble1024.length);
  }

  @State(Scope.Thread)
  public static class Complex1D1024Blocked {
    Complex1D complex = new Complex1D(1024, DataLayout1D.BLOCKED, 1024);
    double[] in = Arrays.copyOf(inDouble1024, inDouble1024.length);
  }

  @State(Scope.Thread)
  public static class Complex64Blocked2DFFT {
    Complex2D complex2D = new Complex2D(64, 64, DataLayout2D.BLOCKED_XY, 64 * 64);
    double[] in = Arrays.copyOf(inDouble2D64Blocked, inDouble2D64Blocked.length);
  }

  @State(Scope.Thread)
  public static class Complex64Interleaved2DFFT {
    Complex2D complex2D = new Complex2D(64, 64, DataLayout2D.INTERLEAVED, 1);
    double[] in = Arrays.copyOf(inDouble2D64Interleaved, inDouble2D64Interleaved.length);
  }

  @State(Scope.Thread)
  public static class Complex64Blocked3DFFT {
    Complex3D complex3D = new Complex3D(64, 64, 64, DataLayout3D.BLOCKED_XY);
    double[] in = Arrays.copyOf(inDouble3D64Blocked, inDouble3D64Blocked.length);
    {
      complex3D.setRecip(inDouble3D64Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex64Blocked3DFFTParallel {
    Complex3DParallel complex3DParallel = new Complex3DParallel(64, 64, 64, parallelTeam, DataLayout3D.BLOCKED_XY);
    double[] in = Arrays.copyOf(inDouble3D64Blocked, inDouble3D64Blocked.length);
    {
      complex3DParallel.setRecip(inDouble3D64Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex64Interleaved3DFFT {
    Complex3D complex3D = new Complex3D(64, 64, 64, DataLayout3D.INTERLEAVED);
    double[] in = Arrays.copyOf(inDouble3D64Interleaved, inDouble3D64Interleaved.length);
    {
      complex3D.setRecip(inDouble3D64Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex64Interleaved3DFFTParallel {
    Complex3DParallel complex3DParallel = new Complex3DParallel(64, 64, 64, parallelTeam, DataLayout3D.INTERLEAVED);
    double[] in = Arrays.copyOf(inDouble3D64Interleaved, inDouble3D64Interleaved.length);
    {
      complex3DParallel.setRecip(inDouble3D64Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex128Blocked2DFFT {
    Complex2D complex2D = new Complex2D(128, 128, DataLayout2D.BLOCKED_XY, 128 * 128);
    double[] in = Arrays.copyOf(inDouble2D128Blocked, inDouble2D128Blocked.length);
  }

  @State(Scope.Thread)
  public static class Complex128Interleaved2DFFT {
    Complex2D complex2D = new Complex2D(128, 128, DataLayout2D.INTERLEAVED, 1);
    double[] in = Arrays.copyOf(inDouble2D128Interleaved, inDouble2D128Interleaved.length);
  }

  @State(Scope.Thread)
  public static class Complex128Blocked3DFFT {
    Complex3D complex3D = new Complex3D(128, 128, 128, DataLayout3D.BLOCKED_XY);
    double[] in = Arrays.copyOf(inDouble3D128Blocked, inDouble3D128Blocked.length);
    {
      complex3D.setRecip(inDouble3D128Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex128Blocked3DFFTParallel {
    Complex3DParallel complex3DParallel = new Complex3DParallel(128, 128, 128, parallelTeam, DataLayout3D.BLOCKED_XY);
    double[] in = Arrays.copyOf(inDouble3D128Blocked, inDouble3D128Blocked.length);
    {
      complex3DParallel.setRecip(inDouble3D128Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex128Interleaved3DFFT {
    Complex3D complex3D = new Complex3D(128, 128, 128, DataLayout3D.INTERLEAVED);
    double[] in = Arrays.copyOf(inDouble3D128Interleaved, inDouble3D128Interleaved.length);
    {
      complex3D.setRecip(inDouble3D128Conv);
    }
  }

  @State(Scope.Thread)
  public static class Complex128Interleaved3DFFTParallel {
    Complex3DParallel complex3DParallel = new Complex3DParallel(128, 128, 128, parallelTeam, DataLayout3D.INTERLEAVED);
    double[] in = Arrays.copyOf(inDouble3D128Interleaved, inDouble3D128Interleaved.length);
    {
      complex3DParallel.setRecip(inDouble3D128Conv);
    }
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0064Interleaved(Complex64 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0064Blocked(Complex64Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0064InterleavedSIMD(Complex64 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0064BlockedSIMD(Complex64Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1,
      jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0128Interleaved(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0128Blocked(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0128InterleavedSIMD(Complex128 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0128BlockedSIMD(Complex128Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0256Interleaved(Complex256 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0256Blocked(Complex256Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0256InterleavedSIMD(Complex256 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0256BlockedSIMD(Complex256Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0512Interleaved(Complex512 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0512Blocked(Complex512Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0512InterleavedSIMD(Complex512 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex0512BlockedSIMD(Complex512Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex1024Interleaved(Complex1024 state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex1024Blocked(Complex1024Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(false);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex1024InterleavedSIMD(Complex1024 state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 2);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex1024BlockedSIMD(Complex1024Blocked state, Blackhole blackhole) {
    state.complex.setUseSIMD(true);
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T1DComplex1024as2D(Complex1D1024Blocked state, Blackhole blackhole) {
    state.complex.fft(state.in, 0, 1);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex064BlockedFFTScalar(Complex64Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex064BlockedFFTSIMD(Complex64Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex064BlockedFFTSIMDPacked(Complex64Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex064InterleavedFFTScalar(Complex64Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex064InterleavedFFTSIMD(Complex64Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex064InterleavedFFTSIMDPacked(Complex64Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064BlockedConvScalar(Complex64Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064BlockedConvSIMD(Complex64Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064BlockedConvSIMDPacked(Complex64Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064BlockedConvSIMDPackedParallel(Complex64Blocked3DFFTParallel state, Blackhole blackhole) {
    state.complex3DParallel.setUseSIMD(true);
    state.complex3DParallel.setPackFFTs(true);
    state.complex3DParallel.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064InterleavedConvScalar(Complex64Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064InterleavedConvSIMD(Complex64Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064InterleavedConvSIMDPacked(Complex64Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex064InterleavedConvSIMDPackedParallel(Complex64Interleaved3DFFTParallel state, Blackhole blackhole) {
    state.complex3DParallel.setUseSIMD(true);
    state.complex3DParallel.setPackFFTs(true);
    state.complex3DParallel.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex128BlockedFFTScalar(Complex128Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex128BlockedFFTSIMD(Complex128Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex128BlockedFFTSIMDPacked(Complex128Blocked2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex128InterleavedFFTScalar(Complex128Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(false);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex128InterleavedFFTSIMD(Complex128Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(false);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(NANOSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T2DComplex128InterleavedFFTSIMDPacked(Complex128Interleaved2DFFT state, Blackhole blackhole) {
    state.complex2D.setUseSIMD(true);
    state.complex2D.setPackFFTs(true);
    state.complex2D.fft(state.in, 0);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128BlockedConvScalar(Complex128Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128BlockedConvSIMD(Complex128Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128BlockedConvSIMDPacked(Complex128Blocked3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.fft(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128BlockedConvSIMDPackedParallel(Complex128Blocked3DFFTParallel state, Blackhole blackhole) {
    state.complex3DParallel.setUseSIMD(true);
    state.complex3DParallel.setPackFFTs(true);
    state.complex3DParallel.fft(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128InterleavedConvScalar(Complex128Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(false);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128InterleavedConvSIMD(Complex128Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(false);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128InterleavedConvSIMDPacked(Complex128Interleaved3DFFT state, Blackhole blackhole) {
    state.complex3D.setUseSIMD(true);
    state.complex3D.setPackFFTs(true);
    state.complex3D.convolution(state.in);
    blackhole.consume(state.in);
  }

  @Benchmark
  @BenchmarkMode(AverageTime)
  @OutputTimeUnit(MICROSECONDS)
  @Warmup(iterations = warmUpIterations, time = warmupTime)
  @Measurement(iterations = measurementIterations, time = measurementTime)
  @Fork(value = 1, jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})
  public void T3DComplex128InterleavedConvSIMDPackedParallel(Complex128Interleaved3DFFTParallel state, Blackhole blackhole) {
    state.complex3DParallel.setUseSIMD(true);
    state.complex3DParallel.setPackFFTs(true);
    state.complex3DParallel.convolution(state.in);
    blackhole.consume(state.in);
  }
}


